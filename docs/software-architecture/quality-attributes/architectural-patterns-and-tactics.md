---
sidebar_position: 10
---

# Architectural Patterns & Tactics

## Introduction

Architecture is hard to get right, and most of the times it doesn't. Because of that, the few architectures that are successful in practice are studied and widely reused by other architectures, giving rise to architectural patterns.

**Architectural patterns are a package of already made design decisions, and they're tradeoffs**.

On previous chapters, we saw many quality attributes, and how to achieve them using tactics. **Tactics are building blocks of patterns**, and so a pattern is made out of many tactics.

**Design rarely starts from first principles**. Experienced architects look to tailor, combine and adapt known patterns to the the system's requirements, knowing the value and tradeoffs that each architectural pattern brings to the table.

## Architectural Patterns

An architectural pattern establishes a relationship between:

- A _context_. A recurrent real-world situation that generates a problem that must be solved.
- A _problem_ generated by the context, properly generalized.
- A _solution_. A successful architectural solution to the problem, properly generalized. The solution should describe:
  - The elements that play a role in the pattern
  - The interaction between these elements
  - A topological layout of the components
  - A set of semantic constraints covering topology, element behavior, and interaction mechanisms.

An important thing to know is that using a pattern isn't all-or-nothing, you don't need to completely commit to the pattern's description, there's room for adaptation and you can choose to use or not certain aspects of the pattern, it's your job to understand and make this decisions, knowing it's tradeoffs and consequences.

Architectural patterns are divided by the main set of elements they describe, and so most patterns are C&C patterns.

## Module Patterns

### Layered Pattern

This is a **module pattern**.

**Context**: All complex systems experience the need to develop and evolve portions of the system independently. For this reason the developers of the system need a clear and well-documented separation of concerns, so that modules of the system may be independently developed and maintained.

**Problem**: The software needs to be segmented in such a way that the modules can be developed and evolved separately with little interaction among the parts, supporting portability, modifiability, and reuse.

**Solution**: To achieve this separation of concerns, the layered pattern divides the software into units called layers. Each layer is a grouping of modules that offers a cohesive set of services. There are constraints on the allowed-to-use relationship among the layers: the relations must be unidirectional. Layers completely partition a set of software, and each partition is exposed through a public interface. The layers are created to interact according to a strict ordering relation. If (A,B) is in this relation, we say that the implementation of layer A is allowed to use any of the public facilities provided by layer B. In some cases, modules in one layer might be required to directly use modules in a nonadjacent lower layer; normally only next-lower-layer uses are allowed. This case of software in a higher layer using modules in a nonadjacent lower layer is called layer bridging. If many instances of layer bridging occur, the system may not meet its portability and modifiability goals that strict layering helps to achieve. Upward usages are not allowed in this pattern.

Of course, none of this comes for free. Someone must design and build the layers, which can often add up-front cost and complexity to a system. Also, if the layering is not designed correctly, it may actually get in the way, by not providing the lower-level abstractions that programmers at the higher levels need. And layering always adds a performance penalty to a system. If a call is made to a function in the top-most layer, this may have to traverse many lower layers before being executed by the hardware. Each of these layers adds some overhead of their own, at minimum in the form of context switching.
Layers are almost always drawn as a stack of boxes. The allowed-to-use relation is denoted by geometric adjacency and is read from the top down.

| Topic       | Description                                                                                                                                                                                                                                                                                   |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | The layered pattern defines layers (groupings of modules that offer a cohesive set of services) and a unidirectional allowed-to-use relation among the layers. The pattern is usually shown graphically by stacking boxes representing layers on top of each other.                           |
| Elements    | Layer, a kind of module. The description of a layer should define what modules the layer contains and a characterization of the cohesive set of services that the layer provides.                                                                                                             |
| Relations   | Allowed to use, which is a specialization of a more generic depends-on relation. The design should define what the layer usage rules are (e.g., “a layer is allowed to use any lower layer” or “a layer is allowed to use only the layer immediately below it”) and any allowable exceptions. |
| Constraints | <ul><li> Every piece of software is allocated to exactly one layer. </li><li> There are at least two layers (but usually there are three or more). </li><li> The allowed-to-use relations should not be circular (i.e., a lower layer cannot use a layer above).</li></ul>                    |
| Weaknesses  | <ul><li> The addition of layers adds up-front cost and complexity to a system. </li><li> Layers contribute a performance penalty</li></ul>                                                                                                                                                    |

## C&C Patterns

### Broker Pattern

This is a **C&C pattern**.

**Context**: Many systems are constructed from a collection of services distributed across multiple servers. Implementing these systems is complex because you need to worry about how the systems will interoperate—how they will connect to each other and how they will exchange information—as well as the availability of the component services.

**Problem**: How do we structure distributed software so that service users do not need to know the nature and location of service providers, making it easy to dynamically change the bindings between users and providers?

**Solution**: The broker pattern separates users of services (clients) from providers of services (servers) by inserting an intermediary, called a broker. When a client needs a service, it queries a broker via a service interface. The broker then forwards the client’s service request to a server, which processes the request. The service result is communicated from the server back to the broker, which then returns the result (and any exceptions) back to the requesting client. In this way the client remains completely ignorant of the identity, location, and characteristics of the server. Because of this separation, if a server becomes unavailable, a replacement can be dynamically chosen by the broker. If a server is replaced with a different (compatible) service, again, the broker is the only component that needs to know of this change, and so the client is unaffected. Proxies are commonly introduced as intermediaries in addition to the broker to help with details of the interaction with the broker, such as marshaling and unmarshaling messages.

The down sides of brokers are that they add complexity (brokers and possibly proxies must be designed and implemented, along with messaging protocols) and add a level of indirection between a client and a server, which will add latency to their communication. Debugging brokers can be difficult because they are involved in highly dynamic environments where the conditions leading to a failure may be difficult to replicate. The broker would be an obvious point of attack, from a security perspective, and so it needs to be hardened appropriately. Also a broker, if it is not designed carefully, can be a single point of failure for a large and complex system. And brokers can potentially be bottlenecks for communication.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | The broker pattern defines a runtime component, called a broker, that mediates the communication between a number of clients and servers.                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Elements    | Client, a requester of services <br/>Server, a provider of services <br/>Broker, an intermediary that locates an appropriate server to fulfill a client’s request, forwards the request to the server, and returns the results to the client <br/>Client-side proxy, an intermediary that manages the actual communication with the broker, including marshaling, sending, and unmarshaling of messages <br/>Server-side proxy, an intermediary that manages the actual communication with the broker, including marshaling, sending, and unmarshaling of messages. |
| Relations   | The attachment relation associates clients (and, optionally, client-side proxies) and servers (and, optionally, server-side proxies) with brokers.                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Constraints | The client can only attach to a broker (potentially via a client-side proxy). The server can only attach to a broker (potentially via a serverside proxy).                                                                                                                                                                                                                                                                                                                                                                                                          |
| Weaknesses  | Brokers add a layer of indirection, and hence latency, between clients and servers, and that layer may be a communication bottleneck. The broker can be a single point of failure.<br/> A broker adds up-front complexity.<br/> A broker may be a target for security attacks.<br/> A broker may be difficult to test                                                                                                                                                                                                                                               |

### MVC Pattern

**Context**: User interface software is typically the most frequently modified portion
of an interactive application. For this reason it is important to keep modifications to the user interface software separate from the rest of the system. Users often wish to look at data from different perspectives, such as a bar graph or a pie chart. These representations should both reflect the current state of the data.

**Problem**: How can user interface functionality be kept separate from application functionality and yet still be responsive to user input, or to changes in the underlying application’s data? And how can multiple views of the user interface be created, maintained, and coordinated when the underlying application data changes?

**Solution**: The model-view-controller (MVC) pattern separates application functionality into three kinds of components:

- A model, which contains the application’s data
- A view, which displays some portion of the underlying data and interactswith the user

- A controller, which mediates between the model and the view and manages the notifications of state changes

MVC is not appropriate for every situation. The design and implementation of three distinct kinds of components, along with their various forms of interaction, may be costly, and this cost may not make sense for relatively simple user interfaces. Also, the match between the abstractions of MVC and commercial user interface toolkits is not perfect. The view and the controller split apart input and output, but these functions are often combined into individual widgets. This may result in a conceptual mismatch between the architecture and the user interface toolkit.

The MVC components are connected to each other via some flavor of notification, such as events or callbacks. These notifications contain state updates.

Because these components are loosely coupled, it is easy to develop and test them in parallel, and changes to one have minimal impact on the others.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | The MVC pattern breaks system functionality into three components: a model, a view, and a controller that mediates between the model and the view.                                                                                                                                                                                                                                                                                                    |
| Elements    | The model is a representation of the application data or state, and it contains (or provides an interface to) application logic. <br/> The view is a user interface component that either produces a representation of the model for the user or allows for some form of user input, or both. <br/> The controller manages the interaction between the model and the view, translating user actions into changes to the model or changes to the view. |
| Relations   | The notifies relation connects instances of model, view, and controller, notifying elements of relevant state changes.                                                                                                                                                                                                                                                                                                                                |
| Constraints | There must be at least one instance each of model, view, and controller.                                                                                                                                                                                                                                                                                                                                                                              |

The model component should not interact directly with the controller.
Weaknesses | The complexity may not be worth it for simple user interfaces.The model, view, and controller abstractions may not be good fits forsome user interface toolkits.

### Pipe-and-Filter Pattern

**Context**: Many systems are required to transform streams of discrete data items, from input to output. Many types of transformations occur repeatedly in practice, and so it is desirable to create these as independent, reusable parts.

**Problem**: Such systems need to be divided into reusable, loosely coupled components with simple, generic interaction mechanisms. In this way they can be flexibly combined with each other. The components, being generic and loosely coupled, are easily reused. The components, being independent, can execute in parallel.

**Solution**: The pattern of interaction in the pipe-and-filter pattern is characterized by successive transformations of streams of data. Data arrives at a filter’s input port(s), is transformed, and then is passed via its output port(s) through a pipe to the next filter. A single filter can consume data from, or produce data to, one or more ports

There are several weaknesses associated with the pipe-and-filter pattern. For instance, this pattern is typically not a good choice for an interactive system, as it disallows cycles (which are important for user feedback). Also, having large numbers of independent filters can add substantial amounts of computational overhead, because each filter runs as its own thread or process. Also, pipe-andfilter systems may not be appropriate for long-running computations, without the addition of some form of checkpoint/restore functionality, as the failure of any filter (or pipe) can cause the entire pipeline to fail.

Pipes buffer data during communication. Because of this property, filters can execute asynchronously and concurrently.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | Data is transformed from a system’s external inputs to its external outputs through a series of transformations performed by its filters connected by pipes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Elements    | Filter, which is a component that transforms data read on its input port(s) to data written on its output port(s). Filters can execute concurrently with each other. Filters can incrementally transform data; that is, they can start producing output as soon as they start processing input. Important characteristics include processing rates, input/output data formats, and the transformation executed by the filter. <br/> Pipe, which is a connector that conveys data from a filter’s output port(s) to another filter’s input port(s). A pipe has a single source for its input and a single target for its output. A pipe preserves the sequence of data items, and it does not alter the data passing through. Important characteristics include buffer size, protocol of interaction, transmission speed, and format of the data that passes through a pipe. |
| Relations   | The attachment relation associates the output of filters with the input of pipes and vice versa.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Constraints | Pipes connect filter output ports to filter input ports. <br/> Connected filters must agree on the type of data being passed along the connecting pipe.<br/> Specializations of the pattern may restrict the association of components to an acyclic graph or a linear sequence, sometimes called a pipeline. <br/> Other specializations may prescribe that components have certain named ports, such as the stdin, stdout, and stderr ports of UNIX filters.                                                                                                                                                                                                                                                                                                                                                                                                              |
| Weaknesses  | The pipe-and-filter pattern is typically not a good choice for an interactive system. <br/>Having large numbers of independent filters can add substantial amounts of computational overhead. <br/> Pipe-and-filter systems may not be appropriate for long-running computations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

### Client-Server Pattern

**Context**: There are shared resources and services that large numbers of distributed clients wish to access, and for which we wish to control access or quality of service.
**Problem**: By managing a set of shared resources and services, we can promote modifiability and reuse, by factoring out common services and having to modify these in a single location, or a small number of locations. We want to improve scalability and availability by centralizing the control of these resources and services, while distributing the resources themselves across multiple physical servers.
**Solution**: Clients interact by requesting services of servers, which provide a set of services. Some components may act as both clients and servers. There may be one central server or multiple distributed ones.

The component types are clients and servers; the principal connector type for the client-server pattern is a data connector driven by a request/reply protocol used for invoking services.

Some of the disadvantages of the client-server pattern are that the server can be a performance bottleneck and it can be a single point of failure. Also, decisions about where to locate functionality (in the client or in the server) are often complex and costly to change after a system has been built.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | Clients initiate interactions with servers, invoking services as needed from those servers and waiting for the results of those requests.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Elements    | Client, a component that invokes services of a server component. Clients have ports that describe the services they require. <br/> Server, a component that provides services to clients. Servers have ports that describe the services they provide. Important characteristics include information about the nature of the server ports (such as how many clients can connect) and performance characteristics (e.g., maximum rates of service invocation). <br/>Request/reply connector, a data connector employing a request/reply protocol, used by a client to invoke services on a server. Important characteristics include whether the calls are local or remote, and whether data is encrypted. |
| Relations   | The attachment relation associates clients with servers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Constraints | Clients are connected to servers through request/reply connectors. Server components can be clients to other servers. Specializations may impose restrictions:<ul><li> Numbers of attachments to a given port</li><li> Allowed relations among servers</li></ul>Components may be arranged in tiers, which are logical groupings of related functionality or functionality that will share a host computing environment (covered more later in this chapter).                                                                                                                                                                                                                                            |
| Weaknesses  | Server can be a performance bottleneck.<br/>Server can be a single point of failure. <br/>Decisions about where to locate functionality (in the client or in the server) are often costly to change after a system has been built.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |

### Peer-to-Peer Pattern

**Context**: Distributed computational entities—each of which is considered equally important in terms of initiating an interaction and each of which provides its own resources—need to cooperate and collaborate to provide a service to a distributed community of users.

**Problem**: How can a set of “equal” distributed computational entities be connected to each other via a common protocol so that they can organize and share their services with high availability and scalability?

**Solution**: In the peer-to-peer (P2P) pattern, components directly interact as peers. All peers are “equal” and no peer or group of peers can be critical for the health of the system. Peer-to-peer communication is typically a request/ reply interaction without the asymmetry found in the client-server pattern. That is, any component can, in principle, interact with any other component by requesting its services. The interaction may be initiated by either party—that is, in client-server terms, each peer component is both a client and a server. Sometimes the interaction is just to forward data without the need for a reply. Each peer provides and consumes similar services and uses the same protocol. Connectors in peer-to-peer systems involve bidirectional interactions, reflecting the two-way communication that may exist between two or more peer-to-peer components.

Peers first connect to the peer-to-peer network on which they discover other peers they can interact with, and then initiate actions to achieve their computation by cooperating with other peers by requesting services. Often a peer’s search for another peer is propagated from one peer to its connected peers for a limited number of hops. A peer-to-peer architecture may have specialized peer nodes (called supernodes) that have indexing or routing capabilities and allow a regular peer’s search to reach a larger number of peers.

Peers can be added and removed from the peer-to-peer network with no significant impact, resulting in great scalability for the whole system. This provides flexibility for deploying the system across a highly distributed platform.

Typically multiple peers have overlapping capabilities, such as providing access to the same data or providing equivalent services. Thus, a peer acting as client can collaborate with multiple peers acting as servers to complete a certain task. If one of these multiple peers becomes unavailable, the others can still provide the services to complete the task. The result is improved overall availability. There are also performance advantages: The load on any given peer component acting as a server is reduced, and the responsibilities that might have required more server capacity and infrastructure to support it are distributed. This can decrease the need for other communication for updating data and for central server storage, but at the expense of storing the data locally.

The drawbacks of the peer-to-peer pattern are strongly related to its strengths. Because peer-to-peer systems are decentralized, managing security, data consistency, data and service availability, backup, and recovery are all more complex. In many cases it is difficult to provide guarantees with peer-to-peer systems because the peers come and go; instead, the architect can, at best, offer probabilities that quality goals will be met, and these probabilities typically increase with the size of the population of peers

| Topic       | Description                                                                                                                                                                                                                                                                                                                                             |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | Computation is achieved by cooperating peers that request service from and provide services to one another across a network.                                                                                                                                                                                                                            |
| Elements    | Peer, which is an independent component running on a network node. Special peer components can provide routing, indexing, and peer search capability. <br/> Request/reply connector, which is used to connect to the peer network, search for other peers, and invoke services from other peers. In some cases, the need for a reply is done away with. |
| Relations   | The relation associates peers with their connectors. Attachments may change at runtime.                                                                                                                                                                                                                                                                 |
| Constraints | Restrictions may be placed on the following: <ul> <li> The number of allowable attachments to any given peer</li> <li> The number of hops used for searching for a peer</li> <li> Which peers know about which other peers</li> </ul> Some P2P networks are organized with star topologies, in which peers only connect to supernodes.                  |
| Weaknesses  | Managing security, data consistency, data/service availability, backup, and recovery are all more complex. <br/> Small peer-to-peer systems may not be able to consistently achieve quality goals such as performance and availability.                                                                                                                 |

### Service-Oriented Architecture Pattern

**Context**: A number of services are offered (and described) by service providers and consumed by service consumers. Service consumers need to be ableto understand and use these services without any detailed knowledge of theirimplementation.

**Problem**: How can we support interoperability of distributed components running on different platforms and written in different implementation languages, provided by different organizations, and distributed across the Internet? How can we locate services and combine (and dynamically recombine) them into meaningful coalitions while achieving reasonable performance, security, and availability?

**Solution**: The service-oriented architecture (SOA) pattern describes a collection
of distributed components that provide and/or consume services. In an SOA, service provider components and service consumer components can use different implementation languages and platforms. Services are largely standalone: service providers and service consumers are usually deployed independently, and often belong to different systems or even different organizations. Components have interfaces that describe the services they request from other components and the services they provide. A service’s quality attributes can be specified and guaranteed with a service-level agreement (SLA). In some cases, these are legally binding. Components achieve their computation by requesting services from one another.

SOA pattern can be quite complex to design and implement (due to dynamic binding and the concomitant use of metadata). Other potential problems with this pattern include the performance overhead of the middleware that is interposed between services and clients and the lack of performance guarantees (because services are shared and, in general, not under control of the requester). These weaknesses are all shared with the broker pattern, which is not surprising because the SOA pattern shares many of the design concepts and goals of broker. In addition, because you do not, in general, control the evolution of the services that you use, you may have to endure high and unplanned-for maintenance costs.

The main benefit and the major driver of SOA is interoperability. Because service providers and service consumers may run on different platforms, service-oriented architectures often integrate a variety of systems, including legacy systems. An example of this pattern is REST and SOAP.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | Computation is achieved by a set of cooperating components that provide and/or consume services over a network. The computation is often described using a workflow language.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Elements    | Components: <ul> <li> Service providers, which provide one or more services through published interfaces. Concerns are often tied to the chosen implementation technology, and include performance, authorization constraints, availability, and cost. In some cases these properties are specified in a service-level agreement. </li> <li> Service consumers, which invoke services directly or through an intermediary.</li> <li> Service providers may also be service consumers.</li> <li> ESB, which is an intermediary element that can route and transform messages between service providers and consumers. </li> <li> Registry of services, which may be used by providers to register their services and by consumers to discover services at runtime. </li> <li> Orchestration server, which coordinates the interactions between service consumers and providers based on languages for business processes and workflows.</li></ul>Connectors: <ul> <li> SOAP connector, which uses the SOAP protocol for synchronous communication between web services, typically over HTTP.</li> <li> REST connector, which relies on the basic request/reply operations of the HTTP protocol. </li> <li> Asynchronous messaging connector, which uses a messaging system to offer point-to-point or publish-subscribe asynchronous message exchanges.</li> </ul> |
| Relations   | Attachment of the different kinds of components available to the respective connectors                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Constraints | Service consumers are connected to service providers, but intermediary components (e.g., ESB, registry, orchestration server) may be used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Weaknesses  | SOA-based systems are typically complex to build. You don’t control the evolution of independent services. There is a performance overhead associated with the middleware, and services may be performance bottlenecks, and typically do not provide performance guarantees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

### Publish-Subscribe Pattern

**Context**: There are a number of independent producers and consumers of data that must interact. The precise number and nature of the data producers and consumers are not predetermined or fixed, nor is the data that they share.

**Problem**: How can we create integration mechanisms that support the ability to transmit messages among the producers and consumers in such a way that they are unaware of each other’s identity, or potentially even their existence?

**Solution**: In the publish-subscribe pattern, summarized in Table 13.8, components interact via announced messages, or events. Components may subscribe to a set of events. It is the job of the publish-subscribe runtime infrastructure to make sure that each published event is delivered to all subscribers of that event. Thus, the main form of connector in these patterns is an event bus. Publisher components place events on the bus by announcing them; the connector then delivers those events to the subscriber components that have registered an interest in those events. Any component may be both a publisher and a subscriber.

Publish-subscribe adds a layer of indirection between senders and receivers.
This has a negative effect on latency and potentially scalability, depending on
how it is implemented. One would typically not want to use publish-subscribe in
a system that had hard real-time deadlines to meet, as it introduces uncertainty in
message delivery times.

Also, the publish-subscribe pattern suffers in that it provides less control over ordering of messages, and delivery of messages is not guaranteed (because the sender cannot know if a receiver is listening). This can make the publish-subscribe pattern inappropriate for complex interactions where shared state is critical.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | Components publish and subscribe to events. When an event is announced by a component, the connector infrastructure dispatches the event to all registered subscribers.                                                                                                                                                                                                                                                                                                                                 |
| Elements    | Any C&C component with at least one publish or subscribe port. Concerns include which events are published and subscribed to, and the granularity of events. <br/>The publish-subscribe connector, which will have announce and listen roles for components that wish to publish and subscribe to events.                                                                                                                                                                                               |
| Relations   | The attachment relation associates components with the publishsubscribe connector by prescribing which components announce events and which components are registered to receive events.                                                                                                                                                                                                                                                                                                                |
| Constraints | All components are connected to an event distributor that may be viewed as either a bus—connector—or a component. Publish ports are attached to announce roles and subscribe ports are attached to listen roles. Constraints may restrict which components can listen to which events, whether a component can listen to its own events, and how many publish-subscribe connectors can exist within a system.<br/> A component may be both a publisher and a subscriber, by having ports of both types. |
| Weaknesses  | Typically increases latency and has a negative effect on scalability and predictability of message delivery time. <br/>Less control over ordering of messages, and delivery of messages is not guaranteed.                                                                                                                                                                                                                                                                                              |

The publish-subscribe pattern can take several forms:

- _List-based publish-subscribe_ is a realization of the pattern where every publisher maintains a subscription list—a list of subscribers that have registered an interest in receiving the event. This version of the pattern is less decoupled than others, as we shall see below, and hence it does not provide as much modifiability, but it can be quite efficient in terms of runtime overhead. Also, if the components are distributed, there is no single point of failure.
- _Broadcast-based publish-subscribe_ differs from list-based publishsubscribe in that publishers have less (or no) knowledge of the subscribers. Publishers simply publish events, which are then broadcast. Subscribers (or in a distributed system, services that act on behalf of the subscribers) examine each event as it arrives and determine whether the published event is of interest. This version has the potential to be very inefficient if there are lots of messages and most messages are not of interest to a particular subscriber.
- *Content-based publish-subscrib*e is distinguished from the previous two variants, which are broadly categorized as “topic-based.” Topics are predefined events, or messages, and a component subscribes to all events within the topic. Content, on the other hand, is much more general. Each event is associated with a set of attributes and is delivered to a subscriber only if those attributes match subscriber-defined patterns.

### Shared-Data Pattern

**Context**: Various computational components need to share and manipulate large amounts of data. This data does not belong solely to any one of those components.

**Problem**: How can systems store and manipulate persistent data that is accessed by multiple independent components?

**Solution**: In the shared-data pattern, interaction is dominated by the exchange of persistent data between multiple data accessors and at least one shared-data store. Exchange may be initiated by the accessors or the data store. The connector type is data reading and writing. The general computational model associated with shareddata systems is that data accessors perform operations that require data from the data store and write results to one or more data stores. That data can be viewed and acted on by other data accessors. In a pure shared-data system, data accessors interact only through one or more shared-data stores. However, in practice shared-data systems also allow direct interactions between data accessors. The data-store components of a shared-data system provide shared access to data, support data persistence, manage concurrent access to data through transaction management, provide fault tolerance, support access control, and handle the distribution and caching of data values.

Specializations of the shared-data pattern differ with respect to the nature of the stored data—existing approaches include relational, object structures, layered, and hierarchical structures.

Although the sharing of data is a critical task for most large, complex systems, there are a number of potential problems associated with this pattern. For one, the shared-data store may be a performance bottleneck. For this reason, performance optimization has been a common theme in database research. The shared-data store is also potentially a single point of failure. Also, the producers and consumers of the shared data may be tightly coupled, through their knowledge of the structure of the shared data

The shared-data pattern is useful whenever various data items are persistent and have multiple accessors. Use of this pattern has the effect of decoupling the producer of the data from the consumers of the data; hence, this pattern supports modifiability, as the producers do not have direct knowledge of the consumers. Consolidating the data in one or more locations and accessing it in a common fashion facilitates performance tuning. Analyses associated with this pattern usually center on qualities such as data consistency, performance, security, privacy, availability, scalability, and compatibility with, for example, existing repositories and their data.

When a system has more than one data store, a key architecture concern is the
mapping of data and computation to the data. Use of multiple stores may occur because the data is naturally, or historically, partitioned into separable stores. In other
cases data may be replicated over several stores to improve performance or availability through redundancy. Such choices can strongly affect the qualities noted above.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | Communication between data accessors is mediated by a shareddata store. Control may be initiated by the data accessors or the data store. Data is made persistent by the data store.                                                                                                                                                                                   |
| Elements    | Shared-data store. Concerns include types of data stored, data performance-oriented properties, data distribution, and number of accessors permitted. <br/> Data accessor component. <br/> Data reading and writing connector.An important choice here is whether the connector is transactional or not, as well as the read/write language, protocols, and semantics. |
| Relations   | Attachment relation determines which data accessors are connected to which data stores.                                                                                                                                                                                                                                                                                |
| Constraints | Data accessors interact with the data store(s).                                                                                                                                                                                                                                                                                                                        |
| Weaknesses  | The shared-data store may be a performance bottleneck. <br/>The shared-data store may be a single point of failure. <br/> Producers and consumers of data may be tightly coupled.                                                                                                                                                                                      |

## Allocation Patterns

### Map-Reduce Pattern

**Context**: Businesses have a pressing need to quickly analyze enormous volumes of data they generate or access, at petabyte scale. Examples include logs of interactions in a social network site, massive document or data repositories, and pairs of \<source, target\> web links for a search engine. Programs for the analysis of this data should be easy to write, run efficiently, and be resilient with respect to hardware failure.

**Problem**: For many applications with ultra-large data sets, sorting the data and then analyzing the grouped data is sufficient. The problem the map-reduce pattern solves is to efficiently perform a distributed and parallel sort of a large data set and provide a simple means for the programmer to specify the analysis to be done.

**Solution**: The map-reduce pattern requires three parts: First, a specialized infrastructure takes care of allocating software to the hardware nodes in a massively parallel computing environment and handles sorting the data as needed. A node may be a standalone processor or a core in a multi-core chip. Second and third are two programmer-coded functions called, predictably enough, map and reduce.

Some considerations that would argue against adopting this pattern are these:

- If you do not have large data sets, then the overhead of map-reduce is not justified.
- If you cannot divide your data set into similar sized subsets, the advantages of parallelism are lost.
- If you have operations that require multiple reduces, this will be complex to orchestrate.

Commercial implementations of map-reduce provide infrastructure that takes care of assignment of function instances to hardware, recovery and reassignment in case of hardware failure (a common occurrence in massively parallel computing environments), and utilities like sorting of the massive lists that are produced along the way.

| Topic       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | The map-reduce pattern provides a framework for analyzing a large distributed set of data that will execute in parallel, on a set of processors. This parallelization allows for low latency and high availability. The map performs the extract and transform portions of the analysis and the reduce performs the loading of the results. (Extract-transform-load is sometimes used to describe the functions of the map and reduce.)                                                              |
| Elements    | Map is a function with multiple instances deployed across multiple processors that performs the extract and transformation portions of the analysis.<br/>Reduce is a function that may be deployed as a single instance or as multiple instances across processors to perform the load portion of extract-transform-load. <br/>The infrastructure is the framework responsible for deploying map and reduce instances, shepherding the data between them, and detecting and recovering from failure. |
| Relations   | Deploy on is the relation between an instance of a map or reduce function and the processor onto which it is installed. <br/>Instantiate, monitor, and control is the relation between the infrastructure and the instances of map and reduce.                                                                                                                                                                                                                                                       |
| Constraints | The data to be analyzed must exist as a set of files. The map functions are stateless and do not communicate with each other. <br/>The only communication between the map instances and the reduce instances is the data emitted from the map instances as \<key, value\> pairs.                                                                                                                                                                                                                     |
| Weaknesses  | If you do not have large data sets, the overhead of map-reduce is not justified. <br/> If you cannot divide your data set into similar sized subsets, the advantages of parallelism are lost. Operations that require multiple reduces are complex to orchestrate                                                                                                                                                                                                                                    |

### Multi-tier Pattern

The multi-tier pattern is a C&C pattern or an allocation pattern, depending on the criteria used to define the tiers. Tiers can be created to group components of similar functionality, in which case it is a C&C pattern. However, in many, if not most, cases tiers are defined with an eye toward the computing environment on which the software will run: A client tier in an enterprise system will not be running on the computer that hosts the database. That makes it an allocation pattern, mapping software elements—perhaps produced by applying C&C patterns—to computing elements. Because of that reason, we have chosen to list it as an allocation pattern.

**Context**: In a distributed deployment, there is often a need to distribute a system’s infrastructure into distinct subsets. This may be for operational or business reasons (for example, different parts of the infrastructure may belong to different organizations)

**Problem**: How can we split the system into a number of computationally independent execution structures—groups of software and hardware—connected by some communications media? This is done to provide specific server environments optimized for operational requirements and resource usage.

**Solution**: The execution structures of many systems are organized as a set of logical groupings of components. Each grouping is termed a tier. The grouping of components into tiers may be based on a variety of criteria, such as the type of component, sharing the same execution environment, or having the same runtime purpose.

The use of tiers may be applied to any collection (or pattern) of runtime components, although in practice it is most often used in the context of client-server patterns. Tiers induce topological constraints that restrict which components may communicate with other components. Specifically, connectors may exist only between components in the same tier or residing in adjacent tiers. The multi-tier pattern found in many Java EE and Microsoft .NET applications is an example of organization in tiers derived from the client-server pattern.

Additionally, tiers may constrain the kinds of communication that can take place across adjacent tiers. For example, some tiered patterns require call-return communication in one direction but event-based notification in the other.

The main weakness with the multi-tier architecture is its cost and complexity. For simple systems, the benefits of the multi-tier architecture may not justify its up-front and ongoing costs, in terms of hardware, software, and design and implementation complexity.

Tiers are not components, but rather logical groupings of components. Also, don’t confuse tiers with layers! Layering is a pattern of modules (a unit of implementation), while tiers applies only to runtime entities.

Tiers make it easier to ensure security, and to optimize performance and availability in specialized ways. They also enhance the modifiability of the system, as the computationally independent subgroups need to agree on protocols for interaction, thus reducing their coupling.

| Topic       | Description                                                                                                                                                                                                                                                                                                                 |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview    | The execution structures of many systems are organized as a set of logical groupings of components. Each grouping is termed a tier. The grouping of components into tiers may be based on a variety of criteria, such as the type of component, sharing the same execution environment, or having the same runtime purpose. |
| Elements    | Tier, which is a logical grouping of software components. Tiers may be formed on the basis of common computing platforms, in which case those platforms are also elements of the pattern.                                                                                                                                   |
| Relations   | Is part of, to group components into tiers.<br/> Communicates with, to show how tiers and the components they contain interact with each other.<br/> Allocated to, in the case that tiers map to computing platforms.                                                                                                       |
| Constraints | A software component belongs to exactly one tier.                                                                                                                                                                                                                                                                           |
| Weaknesses  | Substantial up-front cost and complexity                                                                                                                                                                                                                                                                                    |

## Relatioships Between Patterns and Tactics

As stated before, patterns are composed of many tactics, and they can be thought of as a package that includes these many tactics. And so tactics are building blocks of patterns.

### Using Tactics to Augment Patterns

A pattern is a solution to a class of problems in a generic context. When a patterns is chosen an applied, the context of it's application becomes very specific.

To make a pattern work in a given architectural context, we must examine the following:

- Which quality attributes the pattern brings to the table, and which tradeoffs it makes. We must compare the pattern quality attributes to the ones we need.
- What are the side effects of using this pattern on other quality attributes?

With that in mind, we're able to examine a pattern to see how much it fits our architectural needs. Very rarely it won't need some sort of tailoring or adapting, and that can be done by the use of tactics.

Let's say we need a system to have high availiability, and also be interoperable within and without itself. We can go with the broker pattern to tackle interoperability, however, one of it's weakenesses is availability. We can then use availability tactics, such as replication, hot spare, and so on, to enrich this pattern with availiability.

### Using Tactics Together

Now that we've seen how we can augment patterns with tactics, we must talk about an important aspect that arises from doing that, tradeoffs.

Every time you choose to add/remove a tactic, there are side-effects on the architecture. It's the job of the architect to weight the benefit from the tactic with it's inherited tradeoff and judge if it's worth it.

Further more, the addition of one tactic may generate a side-effect which will lead to the addition of another tactics, and then another, and so on. In this manner, designing an architecture is much like playing chess, great players can see many moves ahead.
